<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Unusual Pills</title>
  <style>
    :root {
      --max-img: 300px;
    }

    body {
      margin: 0;
      background: url("static/images/background.png") no-repeat center center fixed; 
      background-size: cover;
      color: white;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      flex-direction: column;
      position: relative;      /* absolute positioning anchor */
      overflow: hidden;
    }

    /* Common link/button visuals */
    .logo, .merch-pill, .snail {
      width: min(60vw, var(--max-img));
      max-width: var(--max-img);
      cursor: pointer;
      transition: transform 0.3s ease;
      margin-top: 20px;
      display: block;
    }

    .logo:hover, .merch-pill:hover, .snail:hover {
      transform: scale(1.05);
    }

    /* Left-side glitch face link (desktop/tablet) */
    .snail-link {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 1; /* under main buttons */
      text-decoration: none;
      outline: none;
    }

    /* Make the canvas behave like your images */
    #glitchFace {
      width: min(60vw, var(--max-img));
      max-width: var(--max-img);
      height: auto;              /* JS sets pixel ratio */
      display: block;
      border-radius: 16px;
    }

    /* Center buttons over the left face for click priority */
    .center-links {
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 2;
    }

    /* Focus ring for keyboard users */
    .snail-link:focus-visible #glitchFace {
      outline: 3px solid rgba(255,255,255,0.85);
      outline-offset: 6px;
    }

    /* Mobile: stack, no absolute positioning */
    @media (max-width: 640px) {
      body { 
        overflow: auto; 
        padding: 20px 0; 
        background-attachment: scroll; /* iOS fix */
      }

      .snail-link {
        position: static;
        transform: none;
        margin-top: 10px;
        order: -1; /* show first */
      }

      .logo, .merch-pill, .snail, #glitchFace {
        width: min(80vw, var(--max-img));
      }

      .center-links {
        margin-top: 10px;
      }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .logo:hover, .merch-pill:hover, .snail:hover { transform: none; }
    }
  </style>
</head>
<body>

  <!-- Clickable, JS-drawn "trippy glitch face" linking to art.html -->
  <a class="snail-link" href="art.html" aria-label="Art Page" title="Open Art">
    <canvas id="glitchFace" class="snail">Art</canvas>
  </a>

  <!-- Main links centered -->
  <div class="center-links">
    <!-- Main claw machine start button -->
    <a href="claw.html" aria-label="Start Claw Machine">
      <img src="static/images/unusualpills.png" alt="Rainbow Pills Logo" class="logo" />
    </a>

    <!-- Merch page button -->
    <a href="merch.html" aria-label="Merch Page">
      <img src="static/images/merch.png" alt="Merch Pill" class="merch-pill" />
    </a>
  </div>

  <!-- ORIGINAL glitch face script (unchanged) -->
  <script>
    (() => {
      const canvas = document.getElementById('glitchFace');
      const ctx = canvas.getContext('2d', { alpha: true });
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      function setCanvasSize() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(180, Math.floor(rect.width * dpr));
        canvas.height = Math.max(180, Math.floor((rect.width * 1.1) * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function drawBaseFace(t = 0) {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;

        ctx.clearRect(0, 0, w, h);

        const grad = ctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, 'rgba(255, 0, 200, 0.25)');
        grad.addColorStop(0.5, 'rgba(0, 200, 255, 0.25)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 0.12)');
        ctx.fillStyle = grad;
        roundedRect(ctx, 8, 8, w - 16, h - 16, 16);
        ctx.fill();

        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.fillStyle = 'rgba(20,20,30,0.35)';
        ctx.beginPath();
        const cx = w / 2, cy = h * 0.52, rx = w * 0.36, ry = h * 0.38;
        for (let a = 0; a <= Math.PI * 2 + 0.01; a += Math.PI / 60) {
          const jx = Math.sin(a * 3 + t * 0.002) * 6;
          const jy = Math.cos(a * 2 - t * 0.003) * 6;
          const x = cx + Math.cos(a) * rx + jx;
          const y = cy + Math.sin(a) * ry + jy;
          a === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        drawEye(cx - rx * 0.45, cy - ry * 0.15, w * 0.18, t);
        drawEye(cx + rx * 0.45, cy - ry * 0.1,  w * 0.18, t + 777);
        drawMouth(cx, cy + ry * 0.35, w * 0.42, t);
        noiseOverlay(w, h, 0.06);
      }

      function drawEye(x, y, size, t) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(Math.sin(t * 0.002) * 0.05);
        const w = size, h = size * 0.65;

        const grad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
        grad.addColorStop(0, 'rgba(255,255,255,0.85)');
        grad.addColorStop(1, 'rgba(200,220,255,0.75)');
        ctx.fillStyle = grad;
        roundedRect(ctx, -w/2, -h/2, w, h, h/2);
        ctx.fill();

        const pupilR = Math.min(w, h) * 0.24;
        const px = Math.sin(t * 0.01) * w * 0.08;
        const py = Math.cos(t * 0.013) * h * 0.08;

        ctx.beginPath();
        ctx.fillStyle = 'rgba(10,10,20,0.95)';
        ctx.arc(px, py, pupilR, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(255,0,200,0.7)';
        ctx.lineWidth = 1.8;
        const turns = 2.6;
        ctx.beginPath();
        for (let a = 0; a < Math.PI * 2 * turns; a += 0.08) {
          const r = (a / (Math.PI * 2 * turns)) * pupilR * 0.9;
          const gx = px + Math.cos(a + t * 0.015) * r;
          const gy = py + Math.sin(a + t * 0.017) * r;
          a === 0 ? ctx.moveTo(gx, gy) : ctx.lineTo(gx, gy);
        }
        ctx.stroke();

        ctx.restore();
      }

      function drawMouth(cx, cy, w, t) {
        ctx.save();
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        for (let i = 0; i <= 100; i++) {
          const x = cx - w/2 + (w * i / 100);
          const y = cy + Math.sin(i * 0.25 + t * 0.02) * 6;
          i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.restore();
      }

      function noiseOverlay(w, h, alpha = 0.05) {
        const lines = 5;
        ctx.save();
        for (let i = 0; i < lines; i++) {
          const y = Math.random() * h;
          ctx.globalAlpha = alpha + Math.random() * alpha;
          ctx.fillStyle = 'white';
          ctx.fillRect(0, y, w, 1);
        }
        ctx.restore();

        const specks = Math.floor((w * h) / 5000);
        ctx.save();
        ctx.globalAlpha = alpha;
        for (let i = 0; i < specks; i++) {
          const x = Math.random() * w, y = Math.random() * h;
          ctx.fillStyle = Math.random() > 0.5 ? 'white' : 'black';
          ctx.fillRect(x, y, 1, 1);
        }
        ctx.restore();
      }

      function roundedRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y,     x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x,     y + h, rr);
        ctx.arcTo(x,     y + h, x,     y,     rr);
        ctx.arcTo(x,     y,     x + w, y,     rr);
        ctx.closePath();
      }

      function glitchSlices(t) {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const slices = Math.random() * 3 | 0;
        for (let i = 0; i < slices; i++) {
          const sh = 8 + Math.random() * 24;
          const sy = Math.random() * (h - sh);
          const sx = 0;
          const sw = w;
          const dx = (Math.random() - 0.5) * 16;
          const imgData = ctx.getImageData(sx, sy, sw, sh);
          ctx.clearRect(sx, sy, sw, sh);
          ctx.putImageData(imgData, sx + dx, sy);
        }

        if (Math.random() < 0.25) {
          ctx.globalCompositeOperation = 'screen';
          ctx.drawImage(canvas, 2, 0);
          ctx.globalCompositeOperation = 'multiply';
          ctx.drawImage(canvas, -2, 0);
          ctx.globalCompositeOperation = 'source-over';
        }
      }

      let rafId = null;
      function animate(t) {
        drawBaseFace(t);
        if (!prefersReduced) {
          if (Math.random() < 0.5) glitchSlices(t);
          rafId = requestAnimationFrame(animate);
        }
      }

      function start() {
        setCanvasSize();
        drawBaseFace(0);
        if (!prefersReduced) {
          cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(animate);
        }
      }

      const ro = new ResizeObserver(() => start());
      ro.observe(canvas);

      start();

      const link = canvas.parentElement;
      link.setAttribute('tabindex', '0');
      link.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          link.click();
        }
      });
    })();
  </script>

  <!-- NEW: bottom-right FREE SHIRT button with pulse + click ripple -->
  <script>
    (() => {
      const link = document.createElement('a');
      link.href = "signup.html";   // âœ… updated for GitHub Pages
      link.setAttribute('aria-label', 'Free Shirt Signup');
      link.title = 'Free Shirt';
      Object.assign(link.style, {
        position: 'absolute',
        right: '16px',
        bottom: '16px',
        zIndex: '3',
        textDecoration: 'none',
        outline: 'none'
      });

      const c = document.createElement('canvas');
      c.id = 'freeShirtCanvas';
      c.style.width = 'min(38vw, 240px)';
      c.style.display = 'block';
      c.style.filter = 'drop-shadow(0 6px 20px rgba(0,0,0,0.35))';
      link.appendChild(c);
      document.body.appendChild(link);

      const ctx = c.getContext('2d', { alpha: true });
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      function fitCanvas() {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rectW = Math.max(160, c.getBoundingClientRect().width);
        const rectH = Math.floor(rectW * 0.36); // pill aspect
        c.width = Math.floor(rectW * dpr);
        c.height = Math.floor(rectH * dpr);
        c.style.height = rectH + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function rr(x,y,w,h,r){
        const rad = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rad,y);
        ctx.arcTo(x+w,y,x+w,y+h,rad);
        ctx.arcTo(x+w,y+h,x,y+h,rad);
        ctx.arcTo(x,y+h,x,y,rad);
        ctx.arcTo(x,y,x+w,y,rad);
        ctx.closePath();
      }

      let hovering = false;
      let ripples = []; // {t0:number} each lasts ~0.6s

      function draw(t=0){
        const w = Math.floor(c.clientWidth || 220);
        const h = Math.floor(parseInt(c.style.height||'80',10));
        ctx.clearRect(0,0,w,h);

        // Pulse factor (0..1)
        const pulse = (prefersReduced ? 0 : (Math.sin(t * 0.012) + 1) / 2);
        const scale = 1 + (hovering ? 0.02 * (0.5 + pulse*0.5) : 0);

        // Scaled group for subtle breathing
        ctx.save();
        ctx.translate(w/2, h/2);
        ctx.scale(scale, scale);
        ctx.translate(-w/2, -h/2);

        // Outer glow / background
        const bg = ctx.createLinearGradient(0, 0, w, h);
        bg.addColorStop(0, hovering ? 'rgba(255,120,220,0.42)' : 'rgba(255,0,200,0.30)');
        bg.addColorStop(1, hovering ? 'rgba(80,220,255,0.42)'  : 'rgba(0,200,255,0.30)');
        ctx.save();
        ctx.shadowColor = `rgba(255,0,200,${0.15 + 0.15*pulse})`;
        ctx.shadowBlur  = 24 + 20*pulse;
        rr(4,4,w-8,h-8,h/2);
        ctx.fillStyle = bg; 
        ctx.fill();
        ctx.restore();

        // Inner pill
        rr(8,8,w-16,h-16,(h-16)/2);
        ctx.fillStyle = 'rgba(15,15,25,0.58)'; 
        ctx.fill();
        ctx.lineWidth = 2; 
        ctx.strokeStyle='rgba(255,255,255,0.85)'; 
        ctx.stroke();

        // Label
        const label = 'FREE SHIRT';
        ctx.font = `700 ${Math.floor(h*0.38)}px Arial`;
        ctx.textAlign='center'; 
        ctx.textBaseline='middle';

        if(hovering && !prefersReduced){
          ctx.fillStyle='rgba(255,0,120,0.9)'; ctx.fillText(label,w/2+1.6,h/2);
          ctx.fillStyle='rgba(0,220,255,0.9)'; ctx.fillText(label,w/2-1.6,h/2);
        }
        ctx.fillStyle='rgba(255,255,255,0.97)'; 
        ctx.fillText(label,w/2,h/2);

        // Click ripple rings
        if (!prefersReduced && ripples.length){
          for (let i = ripples.length - 1; i >= 0; i--) {
            const age = (t - ripples[i].t0) / 1000; // seconds
            if (age > 0.6) { ripples.splice(i,1); continue; }
            const a = 1 - age/0.6;
            const r = (h*0.2) + age*(Math.min(w,h)*0.6);
            ctx.beginPath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = `rgba(255,255,255,${0.6*a})`;
            ctx.arc(w/2, h/2, r, 0, Math.PI*2);
            ctx.stroke();
          }
        }

        ctx.restore(); // end scaled group

        // Subtle scanlines
        if(!prefersReduced){
          ctx.save(); 
          ctx.globalAlpha = hovering ? 0.12 : 0.07;
          for(let i=0;i<4;i++){
            const y = ( (t*0.12 + i*17) % h );
            ctx.fillStyle='white'; ctx.fillRect(12,y,w-24,1);
          }
          ctx.restore();
        }
      }

      let raf;
      function loop(ts){ draw(ts); if(!prefersReduced) raf = requestAnimationFrame(loop); }

      function start(){
        cancelAnimationFrame(raf);
        fitCanvas();
        draw(0);
        if(!prefersReduced) raf = requestAnimationFrame(loop);
      }

      const ro = new ResizeObserver(start);
      ro.observe(c);

      c.addEventListener('mouseenter', () => hovering = true);
      c.addEventListener('mouseleave', () => hovering = false);

      // Click ripple, then navigate (tiny delay so ripple is visible)
      link.addEventListener('click', (e) => {
        if (prefersReduced) return; // just navigate immediately
        e.preventDefault();
        ripples.push({ t0: performance.now() });
        setTimeout(() => { window.location.href = link.href; }, 180);
      });

      // Keyboard accessibility
      link.setAttribute('tabindex','0');
      link.addEventListener('keydown', e => {
        if(e.key==='Enter' || e.key===' '){
          e.preventDefault();
          link.click();
        }
      });

      // Keep it tucked nicely on small screens
      function responsivePosition(){
        if(window.innerWidth < 480){ link.style.bottom = '12px'; link.style.right='12px'; }
        else { link.style.bottom='16px'; link.style.right='16px'; }
      }
      window.addEventListener('resize', responsivePosition);
      responsivePosition();

      start();
    })();
  </script>
</body>
</html>
