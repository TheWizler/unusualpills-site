<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Unusual Pills</title>
  <style>
    :root {
      --max-img: 300px;
    }

    body {
      margin: 0;
      background: url("static/images/background.png") no-repeat center center fixed; 
      background-size: cover;
      color: white;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }

    /* Common link/button visuals */
    .logo, .merch-pill, .snail {
      width: min(60vw, var(--max-img));
      max-width: var(--max-img);
      cursor: pointer;
      transition: transform 0.3s ease;
      margin-top: 20px;
      display: block;
    }

    .logo:hover, .merch-pill:hover, .snail:hover {
      transform: scale(1.05);
    }

    /* Left-side glitch face link (desktop/tablet) */
    .snail-link {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 1; /* under main buttons */
      text-decoration: none;
      outline: none;
    }

    /* Make the canvas behave like your images */
    #glitchFace {
      width: min(60vw, var(--max-img));
      max-width: var(--max-img);
      height: auto;              /* JS sets pixel ratio */
      display: block;
      border-radius: 16px;
    }

    /* Center buttons over the left face for click priority */
    .center-links {
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 2;
    }

    /* Focus ring for keyboard users */
    .snail-link:focus-visible #glitchFace {
      outline: 3px solid rgba(255,255,255,0.85);
      outline-offset: 6px;
    }

    /* Mobile: stack, no absolute positioning */
    @media (max-width: 640px) {
      body { 
        overflow: auto; 
        padding: 20px 0; 
        background-attachment: scroll; /* iOS fix */
      }

      .snail-link {
        position: static;
        transform: none;
        margin-top: 10px;
        order: -1; /* show first */
      }

      .logo, .merch-pill, .snail, #glitchFace {
        width: min(80vw, var(--max-img));
      }

      .center-links {
        margin-top: 10px;
      }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .logo:hover, .merch-pill:hover, .snail:hover { transform: none; }
    }
  </style>
</head>
<body>

  <!-- Clickable, JS-drawn "trippy glitch face" linking to art.html -->
  <a class="snail-link" href="art.html" aria-label="Art Page" title="Open Art">
    <canvas id="glitchFace" class="snail">Art</canvas>
  </a>

  <!-- Main links centered -->
  <div class="center-links">
    <!-- Main claw machine start button -->
    <a href="claw.html" aria-label="Start Claw Machine">
      <img src="static/images/unusualpills.png" alt="Rainbow Pills Logo" class="logo" />
    </a>

    <!-- Merch page button -->
    <a href="merch.html" aria-label="Merch Page">
      <img src="static/images/merch.png" alt="Merch Pill" class="merch-pill" />
    </a>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('glitchFace');
      const ctx = canvas.getContext('2d', { alpha: true });
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      function setCanvasSize() {
        // Size the canvas to its CSS box with devicePixelRatio for crispness
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.max(180, Math.floor(rect.width * dpr));
        canvas.height = Math.max(180, Math.floor((rect.width * 1.1) * dpr)); // a bit taller than wide
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
      }

      function drawBaseFace(t = 0) {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;

        // Clear
        ctx.clearRect(0, 0, w, h);

        // Soft background blob
        const grad = ctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, 'rgba(255, 0, 200, 0.25)');
        grad.addColorStop(0.5, 'rgba(0, 200, 255, 0.25)');
        grad.addColorStop(1, 'rgba(255, 255, 255, 0.12)');
        ctx.fillStyle = grad;
        roundedRect(ctx, 8, 8, w - 16, h - 16, 16);
        ctx.fill();

        // Face outline (irregular)
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.fillStyle = 'rgba(20,20,30,0.35)';
        ctx.beginPath();
        const cx = w / 2, cy = h * 0.52, rx = w * 0.36, ry = h * 0.38;
        for (let a = 0; a <= Math.PI * 2 + 0.01; a += Math.PI / 60) {
          const jx = Math.sin(a * 3 + t * 0.002) * 6;
          const jy = Math.cos(a * 2 - t * 0.003) * 6;
          const x = cx + Math.cos(a) * rx + jx;
          const y = cy + Math.sin(a) * ry + jy;
          a === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Eyes (slightly drifting)
        drawEye(cx - rx * 0.45, cy - ry * 0.15, w * 0.18, t);
        drawEye(cx + rx * 0.45, cy - ry * 0.1,  w * 0.18, t + 777);

        // Mouth (glitchy wave)
        drawMouth(cx, cy + ry * 0.35, w * 0.42, t);

        // Random scanlines / speckles
        noiseOverlay(w, h, 0.06);
      }

      function drawEye(x, y, size, t) {
        // Eye socket
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(Math.sin(t * 0.002) * 0.05);
        const w = size, h = size * 0.65;

        // Outer eye
        const grad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
        grad.addColorStop(0, 'rgba(255,255,255,0.85)');
        grad.addColorStop(1, 'rgba(200,220,255,0.75)');
        ctx.fillStyle = grad;
        roundedRect(ctx, -w/2, -h/2, w, h, h/2);
        ctx.fill();

        // Pupil with swirl
        const pupilR = Math.min(w, h) * 0.24;
        const px = Math.sin(t * 0.01) * w * 0.08;
        const py = Math.cos(t * 0.013) * h * 0.08;

        ctx.beginPath();
        ctx.fillStyle = 'rgba(10,10,20,0.95)';
        ctx.arc(px, py, pupilR, 0, Math.PI * 2);
        ctx.fill();

        // Swirl lines
        ctx.strokeStyle = 'rgba(255,0,200,0.7)';
        ctx.lineWidth = 1.8;
        const turns = 2.6;
        ctx.beginPath();
        for (let a = 0; a < Math.PI * 2 * turns; a += 0.08) {
          const r = (a / (Math.PI * 2 * turns)) * pupilR * 0.9;
          const gx = px + Math.cos(a + t * 0.015) * r;
          const gy = py + Math.sin(a + t * 0.017) * r;
          a === 0 ? ctx.moveTo(gx, gy) : ctx.lineTo(gx, gy);
        }
        ctx.stroke();

        ctx.restore();
      }

      function drawMouth(cx, cy, w, t) {
        ctx.save();
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        for (let i = 0; i <= 100; i++) {
          const x = cx - w/2 + (w * i / 100);
          const y = cy + Math.sin(i * 0.25 + t * 0.02) * 6;
          i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.restore();
      }

      function noiseOverlay(w, h, alpha = 0.05) {
        const lines = 5;
        ctx.save();
        for (let i = 0; i < lines; i++) {
          const y = Math.random() * h;
          ctx.globalAlpha = alpha + Math.random() * alpha;
          ctx.fillStyle = 'white';
          ctx.fillRect(0, y, w, 1);
        }
        ctx.restore();

        // speckles
        const specks = Math.floor((w * h) / 5000);
        ctx.save();
        ctx.globalAlpha = alpha;
        for (let i = 0; i < specks; i++) {
          const x = Math.random() * w, y = Math.random() * h;
          ctx.fillStyle = Math.random() > 0.5 ? 'white' : 'black';
          ctx.fillRect(x, y, 1, 1);
        }
        ctx.restore();
      }

      function roundedRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y,     x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x,     y + h, rr);
        ctx.arcTo(x,     y + h, x,     y,     rr);
        ctx.arcTo(x,     y,     x + w, y,     rr);
        ctx.closePath();
      }

      // Horizontal slice glitch
      function glitchSlices(t) {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const slices = Math.random() * 3 | 0;
        for (let i = 0; i < slices; i++) {
          const sh = 8 + Math.random() * 24;
          const sy = Math.random() * (h - sh);
          const sx = 0;
          const sw = w;
          const dx = (Math.random() - 0.5) * 16; // shift
          const imgData = ctx.getImageData(sx, sy, sw, sh);
          ctx.clearRect(sx, sy, sw, sh);
          ctx.putImageData(imgData, sx + dx, sy);
        }

        // RGB split flash (subtle)
        if (Math.random() < 0.25) {
          ctx.globalCompositeOperation = 'screen';
          ctx.drawImage(canvas, 2, 0);
          ctx.globalCompositeOperation = 'multiply';
          ctx.drawImage(canvas, -2, 0);
          ctx.globalCompositeOperation = 'source-over';
        }
      }

      let rafId = null;
      function animate(t) {
        drawBaseFace(t);
        if (!prefersReduced) {
          if (Math.random() < 0.5) glitchSlices(t);
          rafId = requestAnimationFrame(animate);
        }
      }

      function start() {
        setCanvasSize();
        drawBaseFace(0);
        if (!prefersReduced) {
          cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(animate);
        }
      }

      // Resize handling
      const ro = new ResizeObserver(() => start());
      ro.observe(canvas);

      // Kick off
      start();

      // Accessibility: space/enter triggers the link
      const link = canvas.parentElement;
      link.setAttribute('tabindex', '0');
      link.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          link.click();
        }
      });
    })();
  </script>
</body>
</html>

